/* Implementação simplificada do jogo "Campo Minado", 
   distribuído com o Windows.
   Obs: Na janela "Sobre o Campo Minado", aparece a seguinte
   mensagem: "Copyright (c) 1981-2001 Microsoft Corporation
   por Robert Donner e Curt Johnson" */
programa CampoMinado;
inclui "gra*";
inclui "evnt*";
inclui "mat*";

const
  /* número de casas */
  N = 8;

  /* tamanho de uma casa */
  TAM = 20;

  /* total de minas */
  NUM_MINAS = 5;

  /* jogadas */
  PISOU = 1;
  DESMONTOU = 2;

  /* valor especial para mina */
  MINA = -1;
  MINA_DESMONTADA = -2;

tipo
  Campo = arranjo [N, N] de inteiro;

/* temJogada - detecta a próxima jogada; retorna
   não se o usuário pressionar o teclado */
função temJogada(var jogada, lin, col: inteiro): lógico;
var
  tem: lógico;
início
  repita
    esperePor(EV_MOUSE_BAIXO + EV_TECLADO);
    se (últimoEvento() = EV_TECLADO)
      retorne não; /* teclado termina o jogo */

    se (botãoMouse(BM_DIREITO))
      jogada := DESMONTOU
    senão
      jogada := PISOU;
    esperePor(EV_MOUSE_CIMA);
    mouseXY(col, lin);
    col := col div TAM;
    lin := lin div TAM;
  até ((col < N) && (lin < N));
  retorne sim;
fim;

/* dsnCasa - desenha a casa (lin, col) */
procedimento dsnCasa(var campo: Campo; lin, col: inteiro; 
                         visível: lógico);
var
  x1, y1, x2, y2: inteiro;
  corPincel: inteiro;
  t: texto;
início
  /* retângulo associado à casa (lin, col) */
  x1 := col * TAM;
  y1 := lin * TAM;
  x2 := x1 + TAM + 1;
  y2 := y1 + TAM + 1;
  
  /* prepara o desenho */
  t := "";
  se (visível = não)
    corPincel := COR_BRANCO
  senão se (campo[lin, col] < 0)
    corPincel := COR_VERMELHO
  senão
  início
    corPincel := COR_CINZA;
    t := intParaTxt(campo[lin, col]);
  fim;

  /* desenha */
  altCorPincel(Tela, corPincel);
  dsnRet(Tela, x1, y1, x2, y2);
  dsnTxt(Tela, x1 + 2, y1 + 2, t);
fim;

/* dsnCampo - desenha o conteúdo de todas as casas */
procedimento dsnCampo(var campo: Campo; visível: lógico);
var
  lin, col: inteiro;
início
  para (lin := 0; lin < N; lin++)
    para (col := 0; col < N; col++)
      dsnCasa(campo, lin, col, visível);
fim;

/* obtCasaLivre - obtém posição (lin, col) onde
   uma mina pode ser colocada; 
   quando campo[lin,col] <> MINA, a posição está vaga */
procedimento obtCasaLivre(var campo: Campo; 
    var lin, col: inteiro);
início
  repita
    lin := random(N);
    col := random(N);
  até (campo[lin, col] <> MINA);
fim;

/* regEfeitoMina - registra que há uma mina vizinha */
procedimento regEfeitoMina(var campo: Campo;
    lin, col: inteiro);
início
  /* nada a fazer se (lin, col) fora do campo */
  se ((lin < 0) || (lin >= N))
    retorne;
  se ((col < 0) || (col >= N))
    retorne;

  /* nada a fazer se (lin, col) já tem uma mina */
  se (campo[lin, col] = MINA)
    retorne;

  /* registre que há mina vizinha a campo[lin, col] */
  campo[lin, col]++;
fim;

/* regMina - registra presença de mina em (lin,col) e
   o efeito na vizinhança */
procedimento regMina(var campo: Campo; lin, col: inteiro);
início
  campo[lin, col] := MINA;
  regEfeitoMina(campo, lin - 1, col - 1);
  regEfeitoMina(campo, lin - 1, col);
  regEfeitoMina(campo, lin - 1, col + 1);
  regEfeitoMina(campo, lin,     col + 1);
  regEfeitoMina(campo, lin + 1, col + 1);
  regEfeitoMina(campo, lin + 1, col);
  regEfeitoMina(campo, lin + 1, col - 1);
  regEfeitoMina(campo, lin,     col - 1);
fim;

/* coloqueMinas - coloca n minas no campo */
procedimento coloqueMinas(var campo: Campo; n: inteiro);
var
  lin, col: inteiro;
  i: inteiro;
início
  para (i := 0; i < n; i++)
  início
    obtCasaLivre(campo, lin, col);
    regMina(campo, lin, col);
  fim;
fim;

/* exbResult - exibe figura indicando o resultado */
procedimento exbResult(desmontadas: inteiro);
var
  t: texto;
início
  altNomeFonte(Tela, "Wingdings");
  altTamFonte(Tela, 40);
  se (desmontadas = NUM_MINAS)
    t := intParaCrt(74)
  senão
    t := intParaCrt(76);
  dsnTxt(Tela, TAM * N + TAM, TAM, t);
fim;

/* terminou - verifica se descobriu todas as minas */
função terminou(var campo: Campo; 
                jogada, lin, col: inteiro;
                var desmontadas: inteiro): lógico;
início
  se ((jogada = DESMONTOU) && (campo[lin, col] <> MINA_DESMONTADA))
  início
    desmontadas++;
    campo[lin, col] := MINA_DESMONTADA;
  fim;
  retorne (desmontadas = NUM_MINAS);
fim;

var
  campo: Campo;
  desmontadas: inteiro;
  jogada: inteiro;
  lin, col: inteiro;

início
  /* prepara */
  desmontadas := 0;
  coloqueMinas(campo, NUM_MINAS);
  dsnCampo(campo, não);

  /* joga */
  enquanto (temJogada(jogada, lin, col))
  início
    dsnCasa(campo, lin, col, sim);
    se ((jogada = PISOU) && (campo[lin, col] = MINA))
      quebre;
    se ((jogada = DESMONTOU) && (campo[lin, col] >= 0))
      quebre;
    se (terminou(campo, jogada, lin, col, desmontadas))
      quebre;
  fim;

  /* exibe o resultado */
  dsnCampo(campo, sim);
  exbResult(desmontadas);
fim.
