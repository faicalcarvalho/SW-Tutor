/* Algoritmos de pesquisa */
programa pesquisa;
inclui "mat*";

const
  N = 8;

tipo
  itens = arranjo [N] de inteiro;

procedimento ini(var a: itens);
var
  i: inteiro;
início
  para (i:=0; i<N; i++)
    a[i] := random(1000);
//  para (i:=0; i<N; i++)
//    a[i] := i;
//  para (i:=N-1; i>0; i--)
//    a[i] := i;
fim;

/* menor - retorna o índice do menor elemento de a,
   a partir do índice inf */
função menor(var a: itens; inf: inteiro): inteiro;
var
  i: inteiro;    /* controle do loop */
  im: inteiro;   /* índice do menor elemento */
início
  im := inf;
  para (i := inf + 1; i < N; i++)
    se (a[i] < a[im])
      im := i;
  retorne im;
fim;


procedimento imprime(var a: itens);
var
  i: inteiro;
início
  para (i:=0; i<N; i++)
    escreva(a[i], "\n");
fim;

/* glup - mecanismo de troca entre posições adjacentes,
   a[i] e a[i+1]; retorna a última posição em que houve troca */
procedimento glup_antigo(var a: itens; ind: inteiro);
var
  aux: inteiro;
início
  se (a[ind] <= a[ind + 1])
    retorne; // não é necessário fazer a troca
  aux := a[ind];
  a[ind] := a[ind + 1];
  a[ind + 1] := aux;
fim;

/* troca_adj - troca, se necessário, posições
   ajacentes a[ind] e a[ind+1] */
função troca_adj(var a: itens; ind: inteiro): lógico;
var
  aux: inteiro; /* auxiliar para a troca */
início
  se (a[ind] <= a[ind + 1])
    retorne não;
  aux := a[ind];
  a[ind] := a[ind + 1];
  a[ind + 1] := aux;
  retorne sim;
fim;

/* glup - mecanismo de troca entre posições adjacentes,
   a[i] e a[i+1], do início de a até sup; retorna a
   última posição em que houve troca */
função glup(var a: itens; sup: inteiro): inteiro;
var
  i: inteiro;    /* índice inicial */
  ult: inteiro;  /* índice da última troca */
início
  ult := 0;
  para (i := 0; i <= sup; i++)
    se (troca_adj(a, i))
      ult := i;
  retorne ult;
fim;

/* ord_bolha - ordena a em ordem crescente
   usando o método da bolha (bubble sort) */
procedimento ord_bolha(var a: itens);
var
  n: inteiro;
início
  n := N - 1; /* último par: a[N-2] e a[N-1] */
  repita
    n := glup(a, n - 1);
  até (n = 0);
fim;

/* troca - troca a[ind1] com a[ind2] */
procedimento troca(var a: itens; ind1, ind2: inteiro);
var
  aux: inteiro;
início
  se (ind1 = ind2)
    retorne; // não é necessário fazer a troca
  aux := a[ind1];
  a[ind1] := a[ind2];
  a[ind2] := aux;
fim;

procedimento ord_seleção(var a: itens);
var
  i: inteiro;
início
  para (i := 0; i < N - 1; i++)
    troca(a, i, menor(a, i));
fim;

var
  cnt_teste: inteiro;
procedimento teste(var a: itens);
var
  i: inteiro;
início
  cnt_teste++;
  para (i := 0; i < N - 1; i++)
    se (a[i] > a[i + 1])
      termine("erro");
fim;

/* ord_seleção2 - ordena a em ordem crescente
   usando o método da seleção (selection sort) */
procedimento ord_seleção2(var a: itens);
var
  i, j, im: inteiro;
início
  para (i := 0; i < N - 1; i++)
  início
    /* coloca em im o índice do menor */
    im := i;
    para (j := i + 1; j < N; j++)
      se (a[j] < a[im])
        im := j;
    /* coloca em a[i] o menor encontrado em a[im] */
    troca(a, i, im);
  fim;
fim;


procedimento ord_bol(var a: itens);
var i, j, aux: inteiro;
início
  para (i:=0; i<N-1; i++)
    para (j:=i; j<N; j++)
      se (a[i] > a[j])
        troca(a, i, j);
fim;


/* mistura - mistura ordenadamente em a os
   arranjos a[inf..meio] e a[meio+1..sup] */
procedimento mistura(var a: itens;
                     inf, meio, sup: inteiro);
var
  aux: itens;  // para armazenar o arranjo ordenado
  i: inteiro;  // índice do arranjo com a mistura
  i1: inteiro; // índice do arranjo da primeira metade
  i2: inteiro; // índice do arranjo da segunda metade
início
  /* distribui em aux os dois arranjos, até um dos dois acabar */
  i := inf;
  i1 := inf;
  i2 := meio + 1;
  enquanto ((i1 <= meio) && (i2 <= sup))
    se (a[i1] <= a[i2])
    início
      aux[i] := a[i1]; i1++; i++;
    fim
    senão
    início
      aux[i] := a[i2]; i2++; i++;
    fim;

  /* esgota a metade que ainda tem elementos */
  se (i1 <= meio)
    repita
      aux[i] := a[i1]; i1++; i++;
    até (i1 > meio)
  senão
    repita
      aux[i] := a[i2]; i2++; i++;
    até (i2 > sup);

  /* copia aux para a */
  para (i := inf; i <= sup; i++)
    a[i] := aux[i];
fim;

/* ord_mistura - ordena a em ordem crescente,
   do índice inf ao sup, usando o método da
   mistura (merge sort) */
procedimento ord_mistura(var a: itens; inf, sup: inteiro);
var
  meio: inteiro;
início
  se (inf < sup)
  início
    meio := (inf + sup) div 2;
    ord_mistura(a, inf, meio);
    ord_mistura(a, meio + 1, sup);
    mistura(a, inf, meio, sup);
  fim;
fim;

/* psq_seq - retorna índice em a do item pesquisado,
   ou -1 se não encontrar */
função psq_seq(var a: itens; item: inteiro): inteiro;
var
  i: inteiro;
início
  para (i := 0; i < N; i++)
    se (item = a[i])
      retorne i;
  retorne -1; // não encontrou
fim;

/* psq_bin - retorna índice em a (entre inf e sup)
   do item pesquisado, ou -1 se não encontrar */
função psq_bin(var a: itens; item, inf, sup: inteiro): inteiro;
var
  meio: inteiro;
início
  se (inf > sup)
    retorne -1;   // não encontrou

  meio := (inf + sup) div 2;
  se (item = a[meio])
    retorne meio; // encontrou

  se (item < a[meio])
    retorne psq_bin(a, item, inf, meio - 1)
  senão
    retorne psq_bin(a, item, meio + 1, sup);
fim;

/* psq_bin_nr - retorna índice em a do item pesquisado
   ou -1 se não encontrar; implementação não-recursiva */
função psq_bin_nr(var a: itens; item: inteiro): inteiro;
var
  inf, meio, sup: inteiro;
início
  inf := 0;
  sup := N - 1;
  repita
    meio := (inf + sup) div 2;
    se (item = a[meio])
      retorne meio; // encontrou
    se (item < a[meio])
      sup := meio - 1
    senão
      inf := meio + 1;
  até (inf > sup);
  retorne -1; // não encontrou
fim;

var
  a: itens;
  i: inteiro;

início
  para (i := 0; i < 1; i++)
  início
    ini(a);
    //ord_seleção(a);
    //ord_seleção2(a);
    //ord_bolha(a);
    ord_mistura(a, 0, N-1);
    teste(a);
  fim;
  imprime(a);
  escreva("Testes: ", cnt_teste);
fim.
